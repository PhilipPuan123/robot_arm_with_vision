while(loopCondition == 0){

        if(!vid.read(frame))
            break;

        aruco::detectMarkers(frame, markerDictionary, markerCorners, markerIds);
        aruco::estimatePoseSingleMarkers(markerCorners, arucoSquareDimension, cameraMatrix, distanceCoefficients, rotationVectors, translationVectors);

        int max = markerIds.size();
        int basePos = findIndex(markerIds, baseMarker);
        int Pos1 = findIndex(markerIds, toFindMarker);

        aruco::drawAxis(frame, cameraMatrix, distanceCoefficients, rotationVectors[basePos], translationVectors[basePos], 0.08f);
        aruco::drawAxis(frame, cameraMatrix, distanceCoefficients, rotationVectors[Pos1], translationVectors[Pos1], 0.08f);
        imshow("Webcam", frame);
        findRelativeVector(basePos, Pos1, translationVectors, rotationVectors, relPos1);
        markerIds.resize(2); markerIds[0] = -1;  markerIds[1] = -1;

        char character = waitKey(1000/fps);
        switch(character)
        {
            case' ': //space_bar
                if(Pos1 != -1 && basePos != -1){
                    /* what follows is a cheap optimization, a larger Y is usually correct */
                    for(int i = 0; i<5; i++){
                        if(!vid.read(frame))
                            break;
                        aruco::detectMarkers(frame, markerDictionary, markerCorners, markerIds);
                        aruco::estimatePoseSingleMarkers(markerCorners, arucoSquareDimension, cameraMatrix, distanceCoefficients, rotationVectors, translationVectors);

                        int max = markerIds.size();
                        int basePos = findIndex(markerIds, baseMarker);
                        int Pos1 = findIndex(markerIds, toFindMarker);

                        for(int i = 0; i < max; i++){
                            aruco::drawAxis(frame, cameraMatrix, distanceCoefficients, rotationVectors[i], translationVectors[i], 0.08f);
                        }
                        imshow("Webcam", frame);

                        findRelativeVector(basePos, Pos1, translationVectors, rotationVectors, relPos1);
                        new_y = relPos1[1];
                        if(new_y > old_y){
                            relPos1[1] = new_y;
                            old_y = new_y;
                            findRotMatrix(basePos, Pos1, translationVectors, rotationVectors, relativeRotMatrix);
                        }
                        else if(new_y < old_y){
                            relPos1[1] = old_y;
                        }
                        cout << new_y*100 <<  "   y_base=" << translationVectors[basePos][1]*100  << "  y_pos=" << translationVectors[Pos1][1]*100 << endl;
                        markerIds.resize(2); markerIds[0] = -1;  markerIds[1] = -1;
                        waitKey(1000/fps);

                    }
                    loopCondition = 1;

                }
                break;
            case 13: //enter key
                break;
            case 27: //escape key
            /* relativeMatrix is used as the rotation matrix between the baseMarker and the toFindMarker */
            Mat relativeMatrix = Mat::eye(3,3, CV_64F);
            Rodrigues(rotationVectors[Pos1],relativeMatrix);
            printf("\n%lf %lf %lf", relativeMatrix.at<double>(0,0), relativeMatrix.at<double>(0,1), relativeMatrix.at<double>(0,2));
            printf("\n%lf %lf %lf", relativeMatrix.at<double>(1,0), relativeMatrix.at<double>(1,1), relativeMatrix.at<double>(1,2));
            printf("\n%lf %lf %lf", relativeMatrix.at<double>(2,0), relativeMatrix.at<double>(2,1), relativeMatrix.at<double>(2,2));
            //printf("%lf %lf %lf \n ", rotationVectors[0][0]*radtodeg, rotationVectors[0][1]*radtodeg, rotationVectors[0][2]*radtodeg);
            //waitKey();
            loopCondition = 1;
            return -1;
            break;
        }
	}